//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AttendMeBackendClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    attendergroupSave(body: AttenderGroup | undefined): Promise<AttenderGroup> {
        let url_ = this.baseUrl + "/attendergroup/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAttendergroupSave(_response);
        });
    }

    protected processAttendergroupSave(response: Response): Promise<AttenderGroup> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttenderGroup;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttenderGroup>(null as any);
    }

    /**
     * @param attenderGroupId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    attendergroupMemberAdd(attenderGroupId: number | undefined, userId: number | undefined): Promise<AttenderGroup> {
        let url_ = this.baseUrl + "/attendergroup/member/add?";
        if (attenderGroupId === null)
            throw new Error("The parameter 'attenderGroupId' cannot be null.");
        else if (attenderGroupId !== undefined)
            url_ += "attenderGroupId=" + encodeURIComponent("" + attenderGroupId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAttendergroupMemberAdd(_response);
        });
    }

    protected processAttendergroupMemberAdd(response: Response): Promise<AttenderGroup> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttenderGroup;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttenderGroup>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    courseSave(body: Course | undefined): Promise<Course> {
        let url_ = this.baseUrl + "/course/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseSave(_response);
        });
    }

    protected processCourseSave(response: Response): Promise<Course> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Course;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Course>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    courseGroupSave(body: CourseGroup | undefined): Promise<CourseGroup> {
        let url_ = this.baseUrl + "/course/group/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseGroupSave(_response);
        });
    }

    protected processCourseGroupSave(response: Response): Promise<CourseGroup> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CourseGroup;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseGroup>(null as any);
    }

    /**
     * @param courseGroupId (optional) 
     * @param userId (optional) 
     * @return Success
     */
    courseGroupAttenderUserAdd(courseGroupId: number | undefined, userId: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/course/group/attender-user/add?";
        if (courseGroupId === null)
            throw new Error("The parameter 'courseGroupId' cannot be null.");
        else if (courseGroupId !== undefined)
            url_ += "courseGroupId=" + encodeURIComponent("" + courseGroupId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseGroupAttenderUserAdd(_response);
        });
    }

    protected processCourseGroupAttenderUserAdd(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param courseGroupId (optional) 
     * @param attenderGroupId (optional) 
     * @return Success
     */
    courseGroupAttenderGroupAdd(courseGroupId: number | undefined, attenderGroupId: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/course/group/attender-group/add?";
        if (courseGroupId === null)
            throw new Error("The parameter 'courseGroupId' cannot be null.");
        else if (courseGroupId !== undefined)
            url_ += "courseGroupId=" + encodeURIComponent("" + courseGroupId) + "&";
        if (attenderGroupId === null)
            throw new Error("The parameter 'attenderGroupId' cannot be null.");
        else if (attenderGroupId !== undefined)
            url_ += "AttenderGroupId=" + encodeURIComponent("" + attenderGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseGroupAttenderGroupAdd(_response);
        });
    }

    protected processCourseGroupAttenderGroupAdd(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param courseGroupId (optional) 
     * @param teacherUserId (optional) 
     * @return Success
     */
    courseGroupTeacherAssign(courseGroupId: number | undefined, teacherUserId: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/course/group/teacher/assign?";
        if (courseGroupId === null)
            throw new Error("The parameter 'courseGroupId' cannot be null.");
        else if (courseGroupId !== undefined)
            url_ += "courseGroupId=" + encodeURIComponent("" + courseGroupId) + "&";
        if (teacherUserId === null)
            throw new Error("The parameter 'teacherUserId' cannot be null.");
        else if (teacherUserId !== undefined)
            url_ += "teacherUserId=" + encodeURIComponent("" + teacherUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseGroupTeacherAssign(_response);
        });
    }

    protected processCourseGroupTeacherAssign(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param sessionId (optional) 
     * @return Success
     */
    courseTeacherSessionGet(sessionId: number | undefined): Promise<CourseSessionListItem> {
        let url_ = this.baseUrl + "/course/teacher/session/get?";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseTeacherSessionGet(_response);
        });
    }

    protected processCourseTeacherSessionGet(response: Response): Promise<CourseSessionListItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CourseSessionListItem;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseSessionListItem>(null as any);
    }

    /**
     * @param courseGroupId (optional) 
     * @return Success
     */
    courseStudentGroupSessionsGet(courseGroupId: number | undefined): Promise<CourseSessionListItem[]> {
        let url_ = this.baseUrl + "/course/student/group/sessions/get?";
        if (courseGroupId === null)
            throw new Error("The parameter 'courseGroupId' cannot be null.");
        else if (courseGroupId !== undefined)
            url_ += "courseGroupId=" + encodeURIComponent("" + courseGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseStudentGroupSessionsGet(_response);
        });
    }

    protected processCourseStudentGroupSessionsGet(response: Response): Promise<CourseSessionListItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CourseSessionListItem[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseSessionListItem[]>(null as any);
    }

    /**
     * @param courseGroupId (optional) 
     * @return Success
     */
    courseStudentAttendanceGet(courseGroupId: number | undefined): Promise<AttendanceLog[]> {
        let url_ = this.baseUrl + "/course/student/attendance/get?";
        if (courseGroupId === null)
            throw new Error("The parameter 'courseGroupId' cannot be null.");
        else if (courseGroupId !== undefined)
            url_ += "courseGroupId=" + encodeURIComponent("" + courseGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseStudentAttendanceGet(_response);
        });
    }

    protected processCourseStudentAttendanceGet(response: Response): Promise<AttendanceLog[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttendanceLog[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttendanceLog[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    courseSessionSave(body: CourseSession | undefined): Promise<CourseSession> {
        let url_ = this.baseUrl + "/course/session/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseSessionSave(_response);
        });
    }

    protected processCourseSessionSave(response: Response): Promise<CourseSession> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CourseSession;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseSession>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    courseStudentSessionsGet(body: CourseSessionListFiltersPagedListParams | undefined): Promise<CourseSessionListItemPagedList> {
        let url_ = this.baseUrl + "/course/student/sessions/get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseStudentSessionsGet(_response);
        });
    }

    protected processCourseStudentSessionsGet(response: Response): Promise<CourseSessionListItemPagedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CourseSessionListItemPagedList;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseSessionListItemPagedList>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    courseTeacherSessionsGet(body: CourseSessionListFiltersPagedListParams | undefined): Promise<CourseSessionListItemPagedList> {
        let url_ = this.baseUrl + "/course/teacher/sessions/get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseTeacherSessionsGet(_response);
        });
    }

    protected processCourseTeacherSessionsGet(response: Response): Promise<CourseSessionListItemPagedList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CourseSessionListItemPagedList;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseSessionListItemPagedList>(null as any);
    }

    /**
     * @param sessionId (optional) 
     * @return Success
     */
    courseSessionAttendanceListGet(sessionId: number | undefined): Promise<CourseSessionAttendanceRecord[]> {
        let url_ = this.baseUrl + "/course/session/attendance-list/get?";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseSessionAttendanceListGet(_response);
        });
    }

    protected processCourseSessionAttendanceListGet(response: Response): Promise<CourseSessionAttendanceRecord[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CourseSessionAttendanceRecord[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CourseSessionAttendanceRecord[]>(null as any);
    }

    /**
     * @param courseSessionId (optional) 
     * @return Success
     */
    courseSessionAttendanceScannerTokenGet(courseSessionId: number | undefined): Promise<TokenResult> {
        let url_ = this.baseUrl + "/course/session/attendance/scanner/token/get?";
        if (courseSessionId === null)
            throw new Error("The parameter 'courseSessionId' cannot be null.");
        else if (courseSessionId !== undefined)
            url_ += "courseSessionId=" + encodeURIComponent("" + courseSessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseSessionAttendanceScannerTokenGet(_response);
        });
    }

    protected processCourseSessionAttendanceScannerTokenGet(response: Response): Promise<TokenResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResult>(null as any);
    }

    /**
     * @param attenderToken (optional) 
     * @return Success
     */
    courseSessionAttendanceRegister(attenderToken: string | undefined): Promise<User> {
        let url_ = this.baseUrl + "/course/session/attendance/register?";
        if (attenderToken === null)
            throw new Error("The parameter 'attenderToken' cannot be null.");
        else if (attenderToken !== undefined)
            url_ += "attenderToken=" + encodeURIComponent("" + attenderToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseSessionAttendanceRegister(_response);
        });
    }

    protected processCourseSessionAttendanceRegister(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as User;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param attendingUserId (optional) 
     * @param courseSessionId (optional) 
     * @param addOrRemove (optional) 
     * @return Success
     */
    courseSessionAttendanceToggle(attendingUserId: number | undefined, courseSessionId: number | undefined, addOrRemove: boolean | undefined): Promise<AttendanceLog[]> {
        let url_ = this.baseUrl + "/course/session/attendance/toggle?";
        if (attendingUserId === null)
            throw new Error("The parameter 'attendingUserId' cannot be null.");
        else if (attendingUserId !== undefined)
            url_ += "attendingUserId=" + encodeURIComponent("" + attendingUserId) + "&";
        if (courseSessionId === null)
            throw new Error("The parameter 'courseSessionId' cannot be null.");
        else if (courseSessionId !== undefined)
            url_ += "courseSessionId=" + encodeURIComponent("" + courseSessionId) + "&";
        if (addOrRemove === null)
            throw new Error("The parameter 'addOrRemove' cannot be null.");
        else if (addOrRemove !== undefined)
            url_ += "addOrRemove=" + encodeURIComponent("" + addOrRemove) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCourseSessionAttendanceToggle(_response);
        });
    }

    protected processCourseSessionAttendanceToggle(response: Response): Promise<AttendanceLog[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AttendanceLog[];
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttendanceLog[]>(null as any);
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    testTokenDecode(token: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/test/token-decode?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTestTokenDecode(_response);
        });
    }

    protected processTestTokenDecode(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param loginName (optional) 
     * @param password (optional) 
     * @return Success
     */
    userLogin(loginName: string | undefined, password: string | undefined): Promise<TokenResult> {
        let url_ = this.baseUrl + "/user/login?";
        if (loginName === null)
            throw new Error("The parameter 'loginName' cannot be null.");
        else if (loginName !== undefined)
            url_ += "loginName=" + encodeURIComponent("" + loginName) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserLogin(_response);
        });
    }

    protected processUserLogin(response: Response): Promise<TokenResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResult>(null as any);
    }

    /**
     * @param deviceUserId (optional) 
     * @return Success
     */
    userDeviceReset(deviceUserId: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/user/device/reset?";
        if (deviceUserId === null)
            throw new Error("The parameter 'deviceUserId' cannot be null.");
        else if (deviceUserId !== undefined)
            url_ += "deviceUserId=" + encodeURIComponent("" + deviceUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserDeviceReset(_response);
        });
    }

    protected processUserDeviceReset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param deviceUserId (optional) 
     * @return Success
     */
    userDeviceRegisterTokenGet(deviceUserId: number | undefined): Promise<TokenResult> {
        let url_ = this.baseUrl + "/user/device/register/token/get?";
        if (deviceUserId === null)
            throw new Error("The parameter 'deviceUserId' cannot be null.");
        else if (deviceUserId !== undefined)
            url_ += "deviceUserId=" + encodeURIComponent("" + deviceUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserDeviceRegisterTokenGet(_response);
        });
    }

    protected processUserDeviceRegisterTokenGet(response: Response): Promise<TokenResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResult;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    userDeviceRegister(body: DeviceRegisterDTO | undefined): Promise<TokenResult> {
        let url_ = this.baseUrl + "/user/device/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserDeviceRegister(_response);
        });
    }

    protected processUserDeviceRegister(response: Response): Promise<TokenResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResult;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResult>(null as any);
    }

    /**
     * @return Success
     */
    userAttendanceTicketGet(): Promise<TokenResult> {
        let url_ = this.baseUrl + "/user/attendance/ticket/get";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserAttendanceTicketGet(_response);
        });
    }

    protected processUserAttendanceTicketGet(response: Response): Promise<TokenResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenResult>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    userGet(userId: number | undefined): Promise<User> {
        let url_ = this.baseUrl + "/user/get?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGet(_response);
        });
    }

    protected processUserGet(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as User;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param loginName (optional) 
     * @param password (optional) 
     * @param body (optional) 
     * @return Success
     */
    userStudentCreate(loginName: string | undefined, password: string | undefined, body: StudentUserDTO | undefined): Promise<number> {
        let url_ = this.baseUrl + "/user/student/create?";
        if (loginName === null)
            throw new Error("The parameter 'loginName' cannot be null.");
        else if (loginName !== undefined)
            url_ += "loginName=" + encodeURIComponent("" + loginName) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserStudentCreate(_response);
        });
    }

    protected processUserStudentCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param loginName (optional) 
     * @param password (optional) 
     * @param body (optional) 
     * @return Success
     */
    userTeacherCreate(loginName: string | undefined, password: string | undefined, body: TeacherUserDTO | undefined): Promise<number> {
        let url_ = this.baseUrl + "/user/teacher/create?";
        if (loginName === null)
            throw new Error("The parameter 'loginName' cannot be null.");
        else if (loginName !== undefined)
            url_ += "loginName=" + encodeURIComponent("" + loginName) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserTeacherCreate(_response);
        });
    }

    protected processUserTeacherCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }
}

export interface AttendanceLog {
    attendanceLogId?: number;
    attenderUserId?: number;
    courseSessionId?: number;
    readonly dateCreated?: Date;
}

export interface AttenderGroup {
    attenderGroupId?: number;
    groupName?: string;
    yearOfStudy?: number;
    studyDirection?: string;
    readonly dateCreated?: Date;
    attenderGroupMembers?: AttenderGroupMember[] | undefined;
}

export interface AttenderGroupMember {
    attenderGroupMemberId?: number;
    memberUserId?: number;
    memberUser?: User;
    attenderGroupId?: number;
    attenderGroup?: AttenderGroup;
    readonly dateCreated?: Date;
}

export interface Course {
    courseId?: number;
    courseName?: string;
    courseDescription?: string;
    readonly dateCreated?: Date;
    courseGroups?: CourseGroup[] | undefined;
}

export interface CourseGroup {
    courseGroupId?: number;
    courseId?: number;
    course?: Course;
    courseGroupType?: string;
    courseGroupName?: string;
    courseGroupDescription?: string | undefined;
    teacherUserId?: number | undefined;
    teacherUser?: User;
    sessions?: CourseSession[] | undefined;
    attenderGroupAssigments?: CourseGroupAttenderGroupAssigment[] | undefined;
    userAssigments?: CourseGroupUserAssigment[] | undefined;
    yearOfStudy?: number;
    semesterCode?: string | undefined;
    dateStart?: Date;
    dateEnd?: Date;
    readonly dateCreated?: Date;
}

export interface CourseGroupAttenderGroupAssigment {
    courseGroupAttenderGroupAssigmentId?: number;
    courseGroupId?: number;
    attenderGroupId?: number | undefined;
    isExcluded?: boolean;
    readonly dateCreated?: Date;
    courseGroup?: CourseGroup;
    attenderGroup?: AttenderGroup;
}

export interface CourseGroupUserAssigment {
    courseGroupUserAssigmentId?: number;
    courseGroupId?: number;
    courseGroup?: CourseGroup;
    userId?: number | undefined;
    readonly dateCreated?: Date;
    isExcluded?: boolean;
    user?: User;
}

export interface CourseSession {
    courseSessionId?: number;
    courseGroupId?: number;
    courseGroup?: CourseGroup;
    locationName?: string;
    dateStart?: Date;
    dateEnd?: Date;
    readonly dateCreated?: Date;
    attendanceLogs?: AttendanceLog[];
}

export interface CourseSessionAttendanceRecord {
    attendanceLogId?: number | undefined;
    courseSessionId?: number;
    attenderUserId?: number | undefined;
    userName?: string | undefined;
    userSurname?: string | undefined;
    studentAlbumIdNumber?: number | undefined;
    attendanceLogMinDateCreated?: Date | undefined;
    readonly wasUserPresent?: boolean;
}

export interface CourseSessionListFilters {
    search?: string | undefined;
    courseName?: string | undefined;
    courseGroupName?: string | undefined;
    locationName?: string | undefined;
    dateStart?: Date | undefined;
    dateEnd?: Date | undefined;
}

export interface CourseSessionListFiltersPagedListParams {
    pageNumber: number;
    pageSize: number;
    filters?: CourseSessionListFilters;
    sortBy?: string | undefined;
}

export interface CourseSessionListItem {
    readonly courseId?: number;
    readonly courseName?: string;
    readonly courseGroupId?: number;
    readonly courseGroupName?: string;
    readonly courseSessionId?: number;
    readonly locationName?: string;
    readonly dateStart?: Date;
    readonly dateEnd?: Date;
}

export interface CourseSessionListItemPagedList {
    items: CourseSessionListItem[];
    totalCount: number;
    pageNumber: number;
    pageSize: number;
    readonly totalPages: number;
}

export interface DeviceRegisterDTO {
    deviceName?: string;
    studentName?: string;
    studentSurname?: string;
    albumIdNumber?: number;
}

export interface ProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export interface Student {
    studentId?: number;
    albumIdNumber?: number;
    currentYearOfStudy?: number;
    readonly dateCreated?: Date;
}

export interface StudentUserDTO {
    readonly userId?: number;
    name?: string;
    surname?: string;
    albumIdNumber?: number;
}

export interface Teacher {
    teacherId?: number;
    academicTitle?: string;
    readonly dateCreated?: Date;
}

export interface TeacherUserDTO {
    readonly userId?: number;
    name?: string;
    surname?: string;
    academicTitle?: string;
}

export interface TokenResult {
    token?: string;
    expires?: Date | undefined;
}

export interface User {
    userId?: number;
    loginName?: string;
    name?: string | undefined;
    surname?: string | undefined;
    studentId?: number | undefined;
    teacherId?: number | undefined;
    student?: Student;
    readonly isStudent?: boolean;
    teacher?: Teacher;
    readonly isTeacher?: boolean;
    readonly dateCreated?: Date;
    deviceName?: string | undefined;
    isAdmin?: boolean;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}